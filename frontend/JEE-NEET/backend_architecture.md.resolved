# The Ultimate Full-Stack Implementation Manual for JEE-NEET Platform

This layout takes you **from scratch** to a **fully functional, optimized platform**. It covers the Backend setup, how to connect it to your Frontend, and exactly how to handle data (Questions/Tests).

---

## üèóÔ∏è PART 1: The Backend (The Brain)

### 1. Setup & Dependencies
Run in terminal:
```bash
mkdir backend
cd backend
npm init -y
npm install express mongoose dotenv cors helmet compression jsonwebtoken bcryptjs redis multer csv-parser
npm install -D nodemon
```

### 2. Folder Structure
Organize your `backend` folder exactly like this:
```text
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/ (db.js, redis.js)
‚îÇ   ‚îú‚îÄ‚îÄ controllers/ (authController.js, adminController.js, testController.js)
‚îÇ   ‚îú‚îÄ‚îÄ middleware/ (auth.js, upload.js, cache.js)
‚îÇ   ‚îú‚îÄ‚îÄ models/ (User.js, Question.js, Test.js)
‚îÇ   ‚îú‚îÄ‚îÄ routes/ (authRoutes.js, adminRoutes.js, testRoutes.js)
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ uploads/ (Create this folder manually for temp file storage)
‚îú‚îÄ‚îÄ .env
‚îî‚îÄ‚îÄ server.js
```

### 3. The Database Models (How data is saved)
**This is how Questions and Tests are linked.**

**`src/models/Question.js`**:
```javascript
const mongoose = require('mongoose');

const questionSchema = new mongoose.Schema({
    exam: { type: String, enum: ['JEE', 'NEET'], required: true, index: true }, // Index for fast filtering
    subject: { type: String, required: true },
    chapter: { type: String, required: true },
    type: { type: String, enum: ['MCQ', 'Numerical'], default: 'MCQ' },
    text: { type: String, required: true },
    options: [{ type: String }], // ["Option A", "Option B"...]
    correctAnswer: { type: Number, required: true }, // 0, 1, 2, or 3
    solution: String,
    difficulty: { type: String, default: 'Medium' }
});

module.exports = mongoose.model('Question', questionSchema);
```

**`src/models/Test.js`**:
```javascript
const mongoose = require('mongoose');

const testSchema = new mongoose.Schema({
    title: { type: String, required: true },
    exam: { type: String, required: true },
    questions: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Question' }], // THIS LINKS TO THE QUESTIONS
    totalMarks: Number,
    duration: Number // seconds
});

module.exports = mongoose.model('Test', testSchema);
```

### 4. Admin Controller (How to Bulk Upload Questions)
This logic reads a JSON file uploaded by Admin and saves 100s of questions at once.

**`src/controllers/adminController.js`**:
```javascript
const Question = require('../models/Question');
const Test = require('../models/Test');
const fs = require('fs');

// 1. Upload Question Bank
exports.uploadQuestions = async (req, res) => {
    try {
        // Read file uploaded by multer
        const filePath = req.file.path;
        const fileData = fs.readFileSync(filePath, 'utf-8');
        const questionsJson = JSON.parse(fileData); // Expecting Array of Questions
        
        // Bulk Insert into MongoDB
        const savedQuestions = await Question.insertMany(questionsJson);
        
        // cleanup file
        fs.unlinkSync(filePath);
        
        res.status(201).json({ message: `Successfully added ${savedQuestions.length} questions` });
    } catch (error) {
        res.status(500).json({ message: 'Upload Failed', error: error.message });
    }
};

// 2. Create Test Series from those Questions
exports.createTest = async (req, res) => {
    try {
        const { title, exam, subject, count } = req.body;
        
        // Randomized Selection: "Pick 30 Physics questions for JEE"
        const questions = await Question.aggregate([
            { $match: { exam, subject } },
            { $sample: { size: parseInt(count) } } // Randomly select 'count' questions
        ]);
        
        const questionIds = questions.map(q => q._id);
        
        const newTest = await Test.create({
            title,
            exam,
            questions: questionIds, // Save just the IDs
            totalMarks: questionIds.length * 4,
            duration: 10800 // 3 hours
        });
        
        res.status(201).json(newTest);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
```

---

## üîå PART 2: Connecting Frontend to Backend

### 1. API Configuration
In your Frontend (`src/api/axios.js`), create a centralized API handler.

```javascript
import axios from 'axios';

// Create Instance
const api = axios.create({
    baseURL: 'http://localhost:5000/api', // Your Backend URL
    headers: {
        'Content-Type': 'application/json'
    }
});

// Interceptor: Automatically Attach Token to every request
api.interceptors.request.use((config) => {
    const token = localStorage.getItem('token');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

export default api;
```

### 2. Fetching Data in Components
**OLD WAY (Static)**:
`import { questions } from '../data/questions';`

**NEW WAY (Dynamic)**:
In `src/pages/MockTestPage.js`:
```javascript
import api from '../api/axios';
import { initializeTest } from '../store/testSlice';

useEffect(() => {
    const fetchTest = async () => {
        try {
            // This hits generic Backend -> Redis -> DB
            const response = await api.get(`/tests/${testId}`);
            dispatch(initializeTest(response.data));
        } catch (error) {
            console.error("Error loading test", error);
        }
    };
    fetchTest();
}, [testId]);
```

---

## ‚ö° PART 3: Optimization & Performance

### 1. Redis Caching (The Speed Layer)
**Where to put it**: In the `routes` before the controller.
**How it works**:
If 1000 students open "JEE Mock 1", the Database query runs **ONE time**. The other 999 get the data from RAM (Redis) in 5ms.

**`src/middleware/cache.js`**:
```javascript
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });
client.connect();

const cache = (duration) => async (req, res, next) => {
    const key = `api:${req.originalUrl}`;
    const cachedData = await client.get(key);
    
    if (cachedData) {
        return res.json(JSON.parse(cachedData));
    }
    
    // Hijack res.json to save to cache before sending
    const originalJson = res.json;
    res.json = (body) => {
        client.setEx(key, duration, JSON.stringify(body));
        originalJson.call(res, body);
    };
    next();
};

module.exports = cache;
```

### 2. Frontend Optimization
*   **Lazy Loading**: You already implemented this (`React.lazy`). Keep it.
*   **Compression**: Use the `compression` middleware in Backend (`app.use(compression())`) to shrink JSON size by 70%.

---

## üìù Step-by-Step Implementation Plan

1.  **Backend Init**: Create the folder and install packages.
2.  **Database Config**: Set up MongoDB Atlas (Free Tier) and put the URI in `.env`.
3.  **Authentication**: Implement the `User` model and `authController`.
4.  **Admin Routes**: Create the `upload` route using the code in Part 1.4.
5.  **Connect**: Go to Frontend, create `src/api/axios.js`, and replace one static import (e.g. TestSeries) with an `api.get()` call.
6.  **Verify**: Log in, Upload a JSON file of questions to Admin, and see them appear in the Database.
